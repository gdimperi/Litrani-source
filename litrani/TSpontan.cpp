// @(#)root/html:$Id: TSpontan.cpp 2008-06-11
// Author: F.X. Gentit <http://gentit.home.cern.ch/gentit/>

/*************************************************************************
* Copyright (C) Those valid for CNRS software.                          *
*************************************************************************/
#include "Riostream.h"
#include "TROOT.h"
#include "TMessErr.h"
#include "TLitGlob.h"
#include "TEqIndex.h"
#include "T3Vector.h"
#include "TLitPhys.h"
#include "TOpticMaterial.h"
#include "TSupplShape.h"
#include "TResults.h"
#include "TPublication.h"
#include "TPhoton.h"
#include "TSpontan.h"

ClassImp(TSpontan)
//______________________________________________________________________________
//
//  (A) - GENERAL DESCRIPTION OF TSPONTAN
//
//  TSpontan creates different kind of sources of light. The point of
//emission must be inside the shape whose name is ShapeName, as provided in
//the constructor. The region of emission (which we will call the beam
//cradle) may be a point, a surface or a volume (see below). Only the part
//of the beam cradle which lies INSIDE the shape ShapeName generates
//photons. The beam cradle is centered at the point (x,y,z), given in LCS
//(Local Coordinate System) of the shape.
//
//  If you ONLY call the constructor TSpontan, what you can have is simply
//
//     - either a point of emission of photons (x,y,z) and photons generated
//isotropically on 4 pi from this point.
//     - or photons coming out from one face of the shape in the direction
//normal to the face, pointing outside.
//
//  But you may have a much more sophisticated beam of photons if you call
//the methods DefineCradle() and DefineBeam(). See these methods.
//
//  DefineCradle() allow you to have a beam generated either from :
//
//  - a point
//  - a disk
//  - an ellipse
//  - a rectangle or a parallelogram
//  - a parallelipiped , rectangle or not.
//
//  DefineBeam() allows you to have the following distributions for the k
//vectors of the photons of the beam [ t = theta, f = phi ] :
//
//  - "on4pi"           : isotropic on 4 pi, i.e. sin(t)dtdf) with 0<=t<=2pi
//  - "flat"            : sin(t)dtdf) with 0<=t<=aperture around a given direction
//                  AxBeam.
//  - "sinuscosinus"    : favouring sligthly the forward direction, i.e. 
//                  sin(t)cos(t)dtdf with 0<=t<=aperture around a given
//                  direction AxBeam.
//  - "provided"        : with a distribution provided by the user but still with
//                  0<=t<=aperture.
//
//  DefineBeam() also allows you to ask for a polarized beam, but not inside
//an anisotropic material. If you want a polarized beam inside an
//anisotropic material, generates the polarized beam inside an isotropic
//material, and let it enter into the anisotropic material. Notice that you
//will be only partially obeyed when you ask that the polarization of the
//photon ( the direction of its electric field E ) has a given direction !
//The E field HAS to be orthogonal to the k vector of the photon in isotro-
//pic material, so that the direction you have required for the E field
//will be changed, as few as possible, so that k and E are orthogonal.
//  In anisotropic material, once the direction of the k vector is fixed, 
//there are 2 possible solutions for the index, n1 or n2. You can ask that
//the choice between the 2 be random, or ask that the biggest, or smallest
//n be taken.
//
//  Look at the methods DefineCradle() and DefineBeam() for more
//informations.
//
//  It is vital to define sources like TSpontan AFTER the geometry of the
//setup is totally defined, AFTER all calls to TSNode, i.e. AFTER the whole
//set-up is in WCS (World Coordinate System), no more in LCS (Local
//Coordinate System), even if you have to provide all coordinates in the
//LCS of the shape : all coordinates you provide will be transformed into
//WCS.
//
//  With TSpontan, you can simulate all types of beam of photons :
//
// - photons generated spontaneously at a point, on a surface or volume of
//    the shape.
// - beam of photons coming from a laser (polarized or not).
// - beam of photons issuing from an optical fibre.
//
//  The only type of photons that you cannot simulate with TSpontan are:
// (1) the ones generated by the crossing of a particle. For this, look
//     at class TBeam.
// (2) the ones generated by an electromagnetic shower. For this, look
//     at class TElecCascade
// (3) the ones generated by gammas of less than 1 Mev. For this, look
//     at class TPhotoElecCompton.
//
//  With the 1st or the 3rd constructor, the spectrum of the emitted photons
//is the one of the material of the shape "ShapeName". It means that this
//material has to be defined as fluorescent. See the class descriptions
//of TLitSpectrum and of TOpticMaterial to know how to do. 
//  If you use the 2nd or 4th constructor, containing a value for the
//wavelength, then all photons will be generated with this value of
//wavelength NOT TAKING INTO ACCOUNT the fluorescent characteristics of
//the material. In this case, it is not necessary that the material be
//fluorescent.
//
//  Always keep in mind that what you generate is the distribution for the k
//vector of the photon, not the distribution for the P (Poyinting) vector of
//the photons. In isotropic material, both are the same, but not in
//anisotropic material, so that for instance if you have asked for an
//isotropic k vector generation, the photons will not be generated
//isotropically in anisotropic material !
//  In fact there is a real problem here : do the photons generated in an
//anisotropic medium have a k vector isotropic ? Probably not, but this
//problem is overlooked in Litrani. If you have informations about the
//anisotropic generation of photons in anisotropic materials, please give
//me the references.
//
//  There are 4 instances of the constructor :
//
//    (1) - The 1st one has to be used when wavelengths are not fixed and
//          the photons are not issued from one face of the shape ShapeName
//          (when the beam cradle is not a face of the shape).
//    (2) - The 2nd one has to be used when wavelengths are fixed and
//          the photons are not issued from one face of the shape ShapeName
//          (when the beam cradle is not a face of the shape).
//    (3) - The 3rd one has to be used when wavelengths are not fixed and
//          the photons are issued from one face of the shape ShapeName
//    (4) - The 4th one has to be used when wavelengths are fixed and
//          the photons are issued from one face of the shape ShapeName
//
//  Look at each of these constructors for more details.
//
//  To give more specifications about the beam cradle, call the method
//DefineCradle ( but not in the case you have used constructors (3) or (4)).
//  To give more specifications about the shape of the beam, call the method
//DefineBeam().
//  To generate photons call the method "Gen".
//
//  (B) - SIMULATING AN OPTICAL FIBRE
//
//  Let us give here a detailed description on how to simulate an optical
//fibre in Litrani.
//
//     (B1) - Shape for simulating the fibre
//
//  Define a shape of type TSCYL to simulate the fibre. Choose for this
//a material (for instance "plexi") with the right index of refraction of
//your fibre and with an absorption length of 0 ! Why ? It is important to
//understand that in Litrani, the photons are emitted from the face of the
//fibre, BUT FROM WITHIN THE FIBRE ! It means that the photons have first
//to make the transition from within the material of the fibre (plexi) to-
//wards the material at the exit of the fibre (for instance air, or grease,
//or glue). As they have to make this transition, the (small) possibility
//exists that the photon does not make a refraction (does not exit from
//the fibre) but makes a reflection (returns inside the fibre). If it
//happens, it is important that the photon be immediatly killed, since it
//has no chance to come back anymore. It is also important that these pho-
//tons, which have never left the fibre do not count among the emitted
//photons when doing for instance a calculation of efficiency. In Litrani,
//photons having been absorbed into a material of absorption length strictly
//0 are counted apart (into the counter fNpAbsL0 of TResults) and are sub-
//tracted from the generated photons when statistics calculations have to be
//done. This is the reason of this absorption length of 0.
//  You can ask why this extra complication of generating the photons from
//within the internal face of the fibre ? Besides the annoyance described
//above of those photons returning back into the fibre, there is the second
//annoyance that the aperture of the photons of a fibre is generally given
//in air by the manufacturer of the fibre, so that the user of Litrani has
//to convert aperture or angular distribution given in air into aperture
//and angular distribution inside the fibre. The answer is : to avoid the
//much bigger annoyance encountered when the material at the exit of the
//fibre is not air ! Suppose for instance that you intend to do a study of
//many different glues that you intend to put at the exit of the fibre. You
//would have to recalculate aperture and angular distribution for each type
//of glue! With the method of Litrani, you have to do it only once and you
//have nothing to do on the fibre when you change from one type of glue to
//an other type.
//
//     (B2) - Angular distribution of the photons from the fibre
//
//  If you have read the explanations given in (B1), you know at this point
//that you have to give the angular distribution of the photons INSIDE THE
//FIBRE and not in air. You specify the kind of distribution you want by a
//call to DefineBeam(). As is explained above, the angular distribution
//of the photons may be of 4 types :
//
//  - "on4pi"           : isotropic on 4 pi, i.e. sin(t)dtdf) with 0<=t<=2pi
//                  [this case does not make sense for an optical fibre]
//  - "flat"            : sin(t)dtdf) with 0<=t<=aperture around the normal to the
//                  face. [aperture calculated INSIDE the fibre !]
//  - "sinuscosinus"    : favouring sligthly the forward direction, i.e. 
//                  sin(t)cos(t)dtdf with 0<=t<=aperture the normal to the
//                  face.  [aperture calculated INSIDE the fibre !]. (This
//                  type of distribution is closer to the true distribution
//                  of an optical fibre than the preceeding one.)
//  - "provided"        : with a distribution provided by the user but still with
//                  0<=t<=aperture.  [aperture calculated INSIDE the
//                  fibre !]
//
//  In the case you provide yourself the distribution, case "provided",
//please be careful about the following NON TRIVIAL issues :
//    (1) - To know how to define yourself a distribution of type TSplineFit
//to be used to generate random numbers according to a distribution, please
//read the documentation about TSplineFit and in particular the documentation
//about the 2 methods UseForRandom() and GetRandom(). You have to call
//UseForRandom() !
//    (2) - your distribution has to generate theta in radians, not degrees.
//    (3) - you have to give a 2-dimensional distribution, not a 1-dimensio-
//nal distribution. If you have measured yourself the distribution, your
//measurement was very likely a 1-dimensional distribution, (you have
//displaced your instrument inside a plane and you have assumed isotropy in
//phi) so you have to multiply each measurement by sin(t).
//    (4) - you have probably measured your distribution in air, so recalcu-
//lates all angles in the material of the fibre using the Fresnel formula
//        ni sin(ti) = nr sin(tr).
//    (5) - Even if you have provided yourself the distribution, the value
//for aperture still matters : if a t angle is generated from your distribu-
//tion which is bigger than aperture, then we start again until a value
//smaller than aperture is found.
//
//    (B3) - Example
//
//  Suppose your optical fibre is on top of a crystal so that you want the
//photons to be issued from the bottom circular face of the TSCYL. Having
//read the documentation of TSCYL, you know that the bottom circular face
//is face 0. Define your fibre and the generation of photons from your fibre
//in the following way :
//
//$  TOpticMaterial *plexi;
//$  plexi = new TOpticMaterial("Plexi","Plexi",kFALSE,1.0,0.0);
//$  plexi->IsIsotropic("Refr_I_Plexi");
//$  TRevetment *totabsorbing;
//$  totabs = new TRevetment("TotAbsorbing","Totally absorbing revetment");
//$  TSCYL *fibre;
//$  fibre = new TSCYL("fibre","fibre","Plexi","TotAbsorbing",0.01,1.0);
//$  TSpontan *laser;
//$  laser = new TSpontan("laser","laser","fibre",500,0);
//$  laser->DefineBeam(provided,22.5,"AngDistFib");
//
//  This portion of code implies that you have defined beforehand, as fit of
//type TSplineFit :
//      (1) - "Refr_I_Plexi"    the refraction index of the material of the
//                              fibre as a function of wavelength.
//      (2) - "AngDistFib"      the provided angular distribution of photons.
//
//  "Plexi", the material of the fibre, has a magnetic permeability of 1.0
//and an absorption length of 0.0.
//  Except on its exit face, the fibre is considered covered with a totally
//absorbing revetment "TotAbsorbing". Look at the description of TRevetment
//to understand this definition. 
//  The radius of the fibre is 0.01 cm. The length of the fibre is 1.0 cm,
//but this length does not matter at all.
//  It is the 4th constructor of TSpontan which is used, the one for which
//the wavelength of the photons is fixed (here at 500 nm) and for which the
//photons are issued from one face of the shape "fibre" (here face 0).
//  The maximal angle of aperture of the photons, INSIDE THE FIBRE, is 22.5°.
//
//   (C) - Record of death point of photon when seen.
//
//  Look at the new method SetFillDeath() to get a crude way of
//registering the death point of the seen photons into CINT user
//defined histograms. Look at the macro klassen.C to have an example
//of use of this new facility.
//
TSpontan::TSpontan(const char *name,const char *title, const char *ShapeName,
  Double_t x, Double_t y, Double_t z): TNamed(name,title) {
  //  Constructor to be used when the wavelength of the photon is generated
  //according to the distribution associated with the material of the shape, as
  //defined by calls to TOpticMaterial::FluoComponent() and the photons are
  //not issued from one face of the shape ShapeName (when the beam cradle is
  //not a face of the shape).
  //
  //  Arguments :
  //
  //  name      : name of the spontaneous source
  //  title     : title of the spontaneous source
  //  ShapeName : name of the shape in which this spontaneous source is.
  //  x,y,z     : center of the beam cradle in LCS of the shape ShapeName.
  //
  //  After the call to this constructor, the beam cradle is a point located
  //at x,y,z and the k vectors of the photons is generated isotropically on
  //4 pi. If these characteristics do not suit your needs, call the 2 methods :
  //DefineCradle() and DefineBeam().
  //
  TSupplShape *shape;
  InitP();
  fGenFace = -1;
  fFromFace    = kFALSE;
  fWvlgthFixed = kFALSE;
  Bool_t found = kFALSE;
  fChooseIndex = israndom;
  //Verifies that the pointer gOutside points to the correct value (the user may
  //have redefined the material "Outside"
  gLit->VerifyOutside();
  fRun = -1;
  if (!gGs)
    gGs = new TResults("GlobStat","Global statistics of all runs",0);
  TIter next(&gLit->fSupplShape);
  TString s;
  while ((!found) && (shape = (TSupplShape *)next())) {
    s = shape->GetName();
    if (!s.CompareTo(ShapeName)) {
      found = kTRUE;
      fSupplShape = shape;
    }
  }
  if (!found) {
    s = ShapeName;
    gMes->SetName("TSpontan");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,1,"This shape has not been found",s);
  }
  fMat = fSupplShape->GetOptMat();
  if (!fSupplShape->IsFluorescent()) {
    gMes->SetName("TSpontan");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,2,"material of shape not fluorescent");
  }
  fCenter.Set(x,y,z);
  fBeam = new TPhotonCradle(fSupplShape,fCenter);
  if (!gIdx) {
    gIdx = new TEqIndex("TSpontan");
    if (gMes->TestCalc()) gIdx->SetDebug();
  }
  AddToList(name);
}
TSpontan::TSpontan(const char *name,const char *title, const char *ShapeName,
  Double_t x, Double_t y, Double_t z, Double_t wvlgth): TNamed(name,title) {
  //  Constructor to be used when the wavelength of the photon is NOT generated
  //according to the distribution associated with the material of the shape,
  //but is FIXED at the value wvlgth for all generated photons and the photons
  //are not issued from one face of the shape ShapeName (when the beam cradle
  //is not a face of the shape).
  //
  //  Arguments :
  //
  //  name      : name of the spontaneous source
  //  title     : title of the spontaneous source
  //  ShapeName : name of the shape in which this spontaneous source is.
  //  x,y,z     : center of the beam cradle in LCS of the shape ShapeName.
  //  wvlgth    : fixed value of wavelength for all photons, in nanometers.
  //
  //  After the call to this constructor, the beam cradle is a point located
  //at x,y,z and the k vectors of the photons is generated isotropically on
  //4 pi. If these characteristics do not suit your needs, call the 2 methods :
  //DefineCradle() and DefineBeam().
  //
  const Double_t zero = 0.0;
  TSupplShape *shape;
  InitP();
  fGenFace = -1;
  fFromFace    = kFALSE;
  fWvlgthFixed = kTRUE;
  Bool_t found = kFALSE;
  fChooseIndex = israndom;
  //Verifies that the pointer gOutside points to the correct value (the user may
  //have redefined the material "Outside"
  gLit->VerifyOutside();
  fRun = -1;
  if (!gGs)
    gGs = new TResults("GlobStat","Global statistics of all runs",0);
  TIter next(&gLit->fSupplShape);
  TString s;
  while ((!found) && (shape = (TSupplShape *)next())) {
    s = shape->GetName();
    if (!s.CompareTo(ShapeName)) {
      found = kTRUE;
      fSupplShape = shape;
    }
  }
  if (!found) {
    s = ShapeName;
    gMes->SetName("TSpontan");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,4,"This shape has not been found",s);
  }
  fMat = fSupplShape->GetOptMat();
  fWvlgth = wvlgth;
  fT0     = zero;
  fCenter.Set(x,y,z);
  fBeam = new TPhotonCradle(fSupplShape,fCenter);
  if (!gIdx) {
    gIdx = new TEqIndex("TSpontan");
    if (gMes->TestCalc()) gIdx->SetDebug();
  }
  AddToList(name);
}
TSpontan::TSpontan(const char *name,const char *title, const char *ShapeName,
  Int_t iface): TNamed(name,title) {
  //  Constructor to be used when the wavelength of the photon is generated
  //according to the distribution associated with the material of the shape, as
  //defined by calls to TOpticMaterial::FluoComponent() and when you want the
  //photons to be issued from one of the faces of the shape ShapeName.
  //
  //  DO NOT USE THIS CONSTRUCTOR IF YOU INTEND TO CALL METHOD DefineCradle()
  //later on. This is because this constructor does not provide the coordinates
  //of the center of the beam cradle, which would be missing if DefineCradle()
  //changes the cradle to be no more a face of the shape.
  //
  //  Arguments :
  //
  //  name      : name of the spontaneous source
  //  title     : title of the spontaneous source
  //  ShapeName : name of the shape in which this spontaneous source is.
  //  iface     : chooses a face of the shape as beam cradle. To know how faces
  //              are numbered in a shape, look at the documentation of the
  //              relevant shape (TSBRIK, TSCYL,...).
  //
  //  The face iface of the shape ShapeName is the beam cradle. The photons
  //will be issued from this face. Following restriction applies : the chosen
  //face must have the shape of a disk, of a rectangle, or of a parallelogram.
  //No other shape is allowed. Second remark : do not forget to call
  //DefineBeam(), otherwise you will have default values for the beam which
  //may not suit your needs. The default values for the beam are aperture=0
  //and axis of the beam = normal to surface, pointing outside the shape.
  //
  const Double_t zero = 0.0;
  TSupplShape *shape;
  InitP();
  fGenFace = iface;
  fFromFace    = kTRUE;
  fWvlgthFixed = kFALSE;
  Bool_t found = kFALSE;
  fChooseIndex = israndom;
  //Verifies that the pointer gOutside points to the correct value (the user may
  //have redefined the material "Outside"
  gLit->VerifyOutside();
  fRun = -1;
  if (!gGs)
    gGs = new TResults("GlobStat","Global statistics of all runs",0);
  TIter next(&gLit->fSupplShape);
  TString s;
  while ((!found) && (shape = (TSupplShape *)next())) {
    s = shape->GetName();
    if (!s.CompareTo(ShapeName)) {
      found = kTRUE;
      fSupplShape = shape;
    }
  }
  if (!found) {
    s = ShapeName;
    gMes->SetName("TSpontan");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,1,"This shape has not been found",s);
  }
  fMat = fSupplShape->GetOptMat();
  if (!fSupplShape->IsFluorescent()) {
    gMes->SetName("TSpontan");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,2,"material of shape not fluorescent");
  }
  fBeam   = new TPhotonCradle(fSupplShape,iface);
  fCenter = fBeam->GetCenter();
  fBeam->Beam(flat,zero);
  if (!gIdx) {
    gIdx = new TEqIndex("TSpontan");
    if (gMes->TestCalc()) gIdx->SetDebug();
  }
  AddToList(name);
}
TSpontan::TSpontan(const char *name,const char *title, const char *ShapeName,
  Double_t wvlgth, Int_t iface): TNamed(name,title) {
  //  Constructor to be used when the wavelength of the photon is NOT generated
  //according to the distribution associated with the material of the shape,
  //but is FIXED at the value wvlgth for all generated photons and when you
  //want the photons to be issued from one of the faces of the shape ShapeName.
  //
  //  DO NOT USE THIS CONSTRUCTOR IF YOU INTEND TO CALL METHOD DefineCradle()
  //later on. This is because this constructor does not provide the coordinates
  //of the center of the beam cradle, which would be missing if DefineCradle()
  //changes the cradle to be no more a face of the shape.
  //
  //  Arguments :
  //
  //  name      : name of the spontaneous source
  //  title     : title of the spontaneous source
  //  ShapeName : name of the shape in which this spontaneous source is.
  //  wvlgth    : fixed value of wavelength for all photons, in nanometers.
  //  iface     : chooses a face of the shape as beam cradle. To know how faces
  //              are numbered in a shape, look at the documentation of the
  //              relevant shape (TSBRIK, TSCYL,...).
  //
  //  The face iface of the shape ShapeName is the beam cradle. The photons
  //will be issued from this face. Following restriction applies : the chosen
  //face must have the shape of a disk, of a rectangle, or of a parallelogram.
  //No other shape is allowed. Second remark : do not forget to call
  //DefineBeam(), otherwise you will have default values for the beam which
  //may not suit your needs. The default values for the beam are aperture=0
  //and axis of the beam = normal to surface, pointing outside the shape.
  //
  const Double_t zero = 0.0;
  TSupplShape *shape;
  InitP();
  fGenFace = iface;
  fFromFace    = kTRUE;
  fWvlgthFixed = kTRUE;
  Bool_t found = kFALSE;
  fChooseIndex = israndom;
  //Verifies that the pointer gOutside points to the correct value (the user may
  //have redefined the material "Outside"
  gLit->VerifyOutside();
  fRun = -1;
  if (!gGs)
    gGs = new TResults("GlobStat","Global statistics of all runs",0);
  TIter next(&gLit->fSupplShape);
  TString s;
  while ((!found) && (shape = (TSupplShape *)next())) {
    s = shape->GetName();
    if (!s.CompareTo(ShapeName)) {
      found = kTRUE;
      fSupplShape = shape;
    }
  }
  if (!found) {
    s = ShapeName;
    gMes->SetName("TSpontan");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,4,"This shape has not been found",s);
  }
  fMat = fSupplShape->GetOptMat();
  fWvlgth = wvlgth;
  fT0     = zero;
  fBeam = new TPhotonCradle(fSupplShape,iface);
  fCenter = fBeam->GetCenter();
  fBeam->Beam(flat,zero);
  if (!gIdx) {
    gIdx = new TEqIndex("TSpontan");
    if (gMes->TestCalc()) gIdx->SetDebug();
  }
  AddToList(name);
}
TSpontan::~TSpontan() {
  // Destructor. TSpontan is not owner of fHX0, fHY0, fHZ0, fSupplShape, fMat.
  //Do not delete them
  if (fBeam) {
    delete fBeam;
    fBeam = 0;
  }
  if (fPhot) {
    delete fPhot;
    fPhot = 0;
  }
  gLit->fSpontan.Remove(this);
  gLit->fNSpontan--;
}
Bool_t TSpontan::AddToList() const {
  //record the new spontaneous source into gLit->fSpontan
  if (!gLit) {
    gLit = new TLitGlob(85);
    gMes->SetName("AddToList");
    gMes->SetTitle("TSpontan");
    gMes->M(kill_prog,1,"You must define gLit = new TLitGlob(...) first");
  }
  return gLit->AddOneSpontan(this,fName);
}
Bool_t TSpontan::AddToList(const char *name) const {
  //record the new spontaneous source into gLit->fSpontan
  if (!gLit) {
    gLit = new TLitGlob(85);
    gMes->SetName("AddToList");
    gMes->SetTitle("TSpontan");
    gMes->M(kill_prog,2,"You must define gLit = new TLitGlob(...) first");
  }
  return gLit->AddOneSpontan(this,name);
}
void TSpontan::DefineBeam(KindOfDist kind, Double_t aper,Double_t theta,Double_t phi,
  const char *distrib,Bool_t polar,Double_t thetp,Double_t phip,ChoiceOfn selectn) {
  //Defines the characteristics of the beam of photon. This instance of 
  //DefineBeam() is the one to use when the axis of the beam, fAxisb3, is not
  //equal to fAxis3, i.e. when the axis of the beam is not orthogonal to the
  //generating surface of the beam (which is perfectly allowed). Parameters :
  //
  //  kind     : {on4pi,flat,sinuscosinus,provided} [Look into the general descrip-
  //              tion of the class to see the definition of these 4 cases]
  //  aper     : aperture of the beam, in degree, around fAxisb3. 
  //              (default 0)
  //  theta    : theta angle, in degree, in LCS of fSuppl, of fAxisb3.
  //              (default 0)
  //  phi      : phi angle, in degree, in LCS of fSuppl, of fAxisb3.
  //              (default 0) If these 2 parameters are not given, the axis of
  //              the beam, fAxisb3, will be along Oz of LCS of fSuppl.
  //  distrib  : name of the fit or interpolation of type TSplineFit giving
  //              the distribution for the theta angle of the generated
  //              photons around fAxisb3 in case kind == provided.
  //              (default "")
  //  polar    : true if the beam is polarized. Notice that it is forbidden
  //              to choose a polarized beam inside an anisotropic material.
  //              if you want a polarized beam inside an anisotropic material,
  //              generates the polarized beam inside an isotropic material,
  //              and let it enter into the anisotropic material.
  //              (default kFALSE)
  //  thetp    : theta angle, in degree, in LCS of fSuppl, of fPolar, the axis
  //              along which the electric field E of the photons have to be
  //              parallel if polar is true. (default 90)
  //  phip     : phi angle, in degree, in LCS of fSuppl, of fPolar, the axis
  //              along which the electric field E of the photons have to be
  //              parallel if polar is true. (default 0) 
  //              If these 2 parameters are not given, the axis of
  //              polarization, fPolar, will be along Ox of LCS of fSuppl.
  //  selectn  : this last argument only concerns the generation of photons
  //              inside anisotropic material. In anisotropic material, once
  //              the direction of the k vector is fixed, there are 2 possible
  //              solutions for the index, n1 or n2.
  //               - If selectn == random, a random choice will be done
  //                   between n1 and n2 [ this is the default]
  //               - If selectn == biggest, the biggest among (n1,n2) is taken
  //               - If selectn == smallest, the smallest is taken.
  //
  //  Notice that you will be only partially obeyed when you ask that the
  //polarization of the photon ( the direction of its electric field E ) has
  //a given direction ! The E field HAS to be orthogonal to the k vector of
  //the photon in isotropic material. The direction you have required for the
  //E field will be changed, as few as possible, so that k and E are ortho-
  //gonal.
  //
  fChooseIndex = selectn;
  fBeam->Beam(kind,aper,theta,phi,distrib,polar,thetp,phip);
}
void TSpontan::DefineBeam(KindOfDist kind, Double_t aper,const char *distrib,
  Bool_t polar,Double_t thetp, Double_t phip,ChoiceOfn selectn) {
  //Defines the characteristics of the beam of photon. This instance of
  //DefineBeam() is the one to use when the axis of the beam, fAxisb3, is
  //identical to fAxis3, i.e. when the axis of the beam is orthogonal to the
  //generating surface of the beam (or along the 3rd axis of the 
  //parallelipiped). Parameters :
  //
  //  kind     : {on4pi,flat,sinuscosinus,provided} [Look into the general descrip-
  //              tion of the class to see the definition of these 4 cases]
  //  aper     : aperture of the beam, in degree, around fAxisb3.
  //              (default 0)
  //  distrib  : name of the fit or interpolation of type TSplineFit giving
  //              the distribution for the theta angle of the generated
  //              photons around fAxisb3 in case kind == provided.(default "")
  //  polar    : true if the beam is polarized. Notice that it is forbidden
  //              to choose a polarized beam inside an anisotropic material.
  //              if you want a polarized beam inside an anisotropic material,
  //              generates the polarized beam inside an isotropic material,
  //              and let it enter into the anisotropic material.
  //              (default kFALSE)
  //  thetp    : theta angle, in degree, in LCS of fSuppl, of fPolar, the axis
  //              along which the electric field E of the photons have to be
  //              parallel if polar is true. (default 90)
  //  phip     : phi angle, in degree, in LCS of fSuppl, of fPolar, the axis
  //              along which the electric field E of the photons have to be
  //              parallel if polar is true (default 0).
  //              If these 2 parameters are not given, the axis of
  //              polarization, fPolar, will be along Ox of LCS of fSuppl.
  //  selectn  : this last argument only concerns the generation of photons
  //              inside anisotropic material. In anisotropic material, once
  //              the direction of the k vector is fixed, there are 2 possible
  //              solutions for the index, n1 or n2.
  //               - If selectn == random, a random choice will be done
  //                   between n1 and n2 [ this is the default]
  //               - If selectn == biggest, the biggest among (n1,n2) is taken
  //               - If selectn == smallest, the smallest is taken.
  //
  //  Notice that you will be only partially obeyed when you ask that the
  //polarization of the photon ( the direction of its electric field E ) has
  //a given direction ! The E field HAS to be orthogonal to the k vector of
  //the photon in isotropic material. The direction you have required for the
  //E field will be changed, as few as possible, so that k and E are ortho-
  //gonal.
  //
  fChooseIndex = selectn;
  fBeam->Beam(kind,aper,distrib,polar,thetp,phip);
}
void TSpontan::DefineCradle(const char *ShName,KindOfCradle kind,Double_t a1,
  Double_t a2,Double_t a3,Double_t theta3,Double_t phi3,Double_t theta1,Double_t phi1) {
  //  This instance of DefineCradle is for the case where the 3 axis of the
  //beam cradle are orthogonal, i.e. if the beam cradle is a parallelogram
  //then it is a rectangle, and if is a parallelipiped, it is a rectangular
  //parallelipiped. 
  //
  //  Use this instance of DefineCradle if the photon cradle :
  //
  //     - IS A POINT and the angular distribution of the beam is not "on4pi",
  //                  so that you NEED that the axis of the beam be defined.
  //     - IS NOT A FACE OF THE SHAPE. (in that case, use constructor (3) or
  //                                   (4) of TSpontan and call DefineBeam()).
  //     - IS A DISK OR AN ELLIPSE
  //  or - IS A RECTANGLE
  //  or - IS A RECTANGULAR PARALLELIPIPED
  //
  // Notice this important point : all points and vectors are to
  //be given in LCS (LOCAL COORDINATE SYSTEM) of the shape. They will be
  //transformed into the WCS (World Coordinate System) by this method.
  //
  //  The center of the beam cradle has already be given by the call to the
  //constructor (1) or (2).
  //
  //  The parameters are the following :
  //
  //  ShName  : name of shape in which the cradle of the photons is.
  //  kind    : kind of cradle : {point,disk,ellipse,parallelogram,
  //             parallelipiped}
  //  a1      : - radius of disk or
  //            - half-length of 1st axis of ellipse or 
  //            - half-length of parallelogram along fAxis1 or
  //            - half-length of parallelipiped along fAxis1
  //  a2      : - half-length of 2nd axis of ellipse or 
  //            - half-length of parallelogram along fAxis2 or
  //            - half-length of parallelipiped along fAxis2
  //  a3      : - half-length of parallelipiped along fAxis3
  //  theta3  : angle theta (degree, in LCS) of the axis fAxis3, normal to
  //             disk or ellipse or parallelogram, or 3rd axis of
  //             parallelipiped. Default 0.
  //  phi3    : angle phi   (degree, in LCS) of the axis fAxis3, normal to
  //             disk or ellipse or parallelogram, or 3rd axis of
  //             parallelipiped. Default 0.
  //             (if you do not give these 2 parameters, fAxis3 will be along
  //              Oz in LCS)
  //  theta1  : angle theta (degree, in LCS) of the axis fAxis1, 1st axis of
  //             ellipse or 1st axis of parallelogram or parallelipiped.
  //             Default 90.
  //  phi1    : angle phi   (degree, in LCS) of the axis fAxis1, 1st axis of
  //             ellipse or 1st axis of parallelogram or parallelipiped.
  //             Default 0.
  //             (if you do not give these 2 parameters, fAxis1 will be
  //              along Ox in LCS)
  //             (These 2 parameters are irrelevant in case point or disk)
  //
  //  Notice that fAxis2 needs not be given. It can be obtained from fAxis1
  //and fAxis3, because it is assumed in this instance of DefineCradle that
  //fAxis1, fAxis2 and fAxis3 build an orthonormal system.
  //
  TSupplShape *shape;
  TSupplShape *suppl = 0;
  TIter next(&gLit->fSupplShape);
  TString s;
  Bool_t found = kFALSE;
  while ((!found) && (shape = (TSupplShape *)next())) {
    s = shape->GetName();
    if (!s.CompareTo(ShName)) {
      found = kTRUE;
      suppl = shape;
    }
  }
  if (found) {
    if (fBeam) {
      delete fBeam;
      fBeam = 0;
    }
    fBeam = new TPhotonCradle(suppl,fCenter,kind,a1,a2,a3,
      theta3,phi3,theta1,phi1);
  }
  else {
    gMes->SetName("DefineCradle");
    gMes->SetTitle("TSpontan");
    gMes->M(kill_prog,1,"Shape not found");
  }
}
void TSpontan::DefineCradle(const char *ShName,KindOfCradle kind,Double_t a1,
  Double_t a2,Double_t a3,Double_t theta3,Double_t phi3,Double_t theta1,
  Double_t phi1,Double_t theta2,Double_t phi2) {
  //  This instance of DefineCradle is for the MOST general case, without any
  //restriction. fAxis1, fAxis2 and fAxis3 build an orthonormal system only
  //in case of {point,disk,ellipse}. In case of parallelogram, fAxis2 MAY not
  //be orthogonal to fAxis1, but fAxis3 IS orthogonal to fAxis1 and fAxis2,
  //so that the values you provide for fAxis3 (theta3,phi3) are simply ignored!
  //fAxis3 is calculated as = fAxis1^fAxis2. In case of parallelipiped,
  //fAxis1, 2 and 3 can be chosen at will. All values provided are used.
  //
  //  Use this instance of DefineCradle if the photon cradle :
  //
  //     - IS NOT A POINT               (if it is a point, it was sufficient
  //                                     to use the constructor (1) or (2) and
  //                                     to call DefineBeam).
  //     - IS NOT A FACE OF THE SHAPE.  (in that case, use constructor (3) or
  //                                     (4) of TSpontan and call DefineBeam()).
  //     - IS NOT A DISK OR AN ELLIPSE  (you can, but it is easier in that case
  //                                     to use the previous instance of
  //                                     DefineCradle).
  //     - IS A NON RECTANGULAR PARALLELOGRAM
  //  or - IS A NON RECTANGULAR PARALLELIPIPED
  //
  //  Notice this important point : all points and vectors are to
  //be given in LCS (LOCAL COORDINATE SYSTEM) of the shape. They will be
  //transformed into the WCS (World Coordinate System) by this method.
  //
  //  The center of the beam cradle has already be given by the call to the
  //constructor (1) or (2).
  //
  //  The parameters are the following : (no default value for any parameter !)
  //
  //  ShName  : name of shape in which the cradle of the photons is.
  //  kind    : kind of cradle : {point,disk,ellipse,parallelogram,
  //             parallelipiped}
  //  a1      : - radius of disk or
  //            - half-length of 1st axis of ellipse or 
  //            - half-length of parallelogram along fAxis1 or
  //            - half-length of parallelipiped along fAxis1
  //  a2      : - half-length of 2nd axis of ellipse or 
  //            - half-length of parallelogram along fAxis2 or
  //            - half-length of parallelipiped along fAxis2
  //  a3      : - half-length of parallelipiped along fAxis3
  //  theta3  : angle theta (degree, in LCS) of the axis fAxis3, normal to
  //             disk or ellipse or parallelogram, or 3rd axis of
  //             parallelipiped.
  //  phi3    : angle phi   (degree, in LCS) of the axis fAxis3, normal to
  //             disk or ellipse or parallelogram, or 3rd axis of
  //             parallelipiped.
  //             (These 2 parameters are irrelevant in case of point. They
  //             are not used in case of parallelogram, because in that case
  //             fAxis3 = fAxis1^fAxis2)
  //  theta1  : angle theta (degree, in LCS) of the axis fAxis1, 1st axis of
  //             ellipse or 1st axis of parallelogram or parallelipiped.
  //  phi1    : angle phi   (degree, in LCS) of the axis fAxis1, 1st axis of
  //             ellipse or 1st axis of parallelogram or parallelipiped.
  //             (These 2 parameters are irrelevant in case point or disk)
  //  theta2  : angle theta (degree, in LCS) of the axis fAxis2, 2nd axis of
  //             ellipse or 2nd axis of parallelogram or parallelipiped.
  //  phi2    : angle phi   (degree, in LCS) of the axis fAxis2, 2nd axis of
  //             ellipse or 2nd axis of parallelogram or parallelipiped.
  //             (These 2 parameters are irrelevant in case kind == point or
  //              disk or ellipse. They are not used in case of ellipse,
  //              because fAxis2 = fAxi3^fAxis1 in that case)
  //
  TSupplShape *shape;
  TSupplShape *suppl = 0;
  TIter next(&gLit->fSupplShape);
  TString s;
  Bool_t found = kFALSE;
  while ((!found) && (shape = (TSupplShape *)next())) {
    s = shape->GetName();
    if (!s.CompareTo(ShName)) {
      found = kTRUE;
      suppl = shape;
    }
  }
  if (found) {
    if (fBeam) {
      delete fBeam;
      fBeam = 0;
    }
    fBeam = new TPhotonCradle(fCenter,suppl,kind,a1,a2,a3,
      theta3,phi3,theta1,phi1,theta2,phi2);
  }
  else {
    gMes->SetName("DefineCradle");
    gMes->SetTitle("TSpontan");
    gMes->M(kill_prog,1,"Shape not found");
  }
}
void TSpontan::FillDeath() const {
  // This method is called when a photon dies, in order to record the
  //coordinates of the death point, for the cases where the photon is seen.
  Int_t bin;
  if ((fFillDeath) && (gLit->fSeen)) {
    bin = fHX0->Fill(gLit->fX0);
    bin = fHY0->Fill(gLit->fY0);
    bin = fHZ0->Fill(gLit->fZ0);
  }
}
void TSpontan::Gen(Int_t run, Int_t nphot, Double_t xparam, Bool_t runstat,
  Bool_t ForgetLast) {
  //
  //  Starts a run generating nphot photons. The parameters are the following :
  //
  //  run        : run number. Arbitrary, but has to be greater than 0.
  //
  //  nphot      : number of photons to be generated in this run.
  //
  //  xparam     : this parameter is used as abscissa in the plotting of the
  //               results by the class TPublication. For instance, if you
  //               have a setup with a crystal and optical fibre and you
  //               make 10 runs varying the incident angle of the fibre,
  //               you can choose the incident angle of the fibre as xparam.
  //               All plots provided by TPublication will then have the
  //               incident angle of the fibre as x coordinate. You will get
  //               efficiency versus incident angle, and so on. If you do not
  //               give xparam, or give a value smaller than -1.0e+20, all
  //               plots of TPublication will have the run number as x coord.
  //
  //  runstat and ForgetLast :
  //
  //    if runstat == true [Default] AND ForgetLast == false [Default] :
  //
  //      in memory   : this run statistics keeped but this run histos deleted
  //                     when next run begins
  //      on the file : this run statistics and histos recorded
  //
  //            It is the only configuration which allows the working of
  //          TPublication, i.e. allowing to show histograms of quantities
  //          varying as a function of a run dependent parameter.
  //          Usage : normal case : try it first.
  //
  //    if runstat == true AND ForgetLast == true :
  //
  //      in memory   : this run statistics and histograms deleted when next
  //                     run begins.
  //      on the file : this run statistics and histos recorded
  //
  //          Disadvantage : TPublication not working, gGp pointer unavailable
  //          Advantage    : no increase of memory with runs
  //                         per run histograms still available on file
  //          Usage : use this configuration when your number of runs is big
  //                  but you still want per run statistics and histograms
  //                  on file.
  //
  //    if runstat == false ( ForgetLast true or false ) :
  //
  //      in memory   : no statistics and histograms for this run
  //      on the file : no statistics and histograms for this run
  //
  //          Disadvantage : TPublication not working, gGp pointer unavailable
  //                         per run statistics and histograms not available
  //          Advantage    : no increase of memory with runs
  //                         a bit faster, half less histograms to fill
  //          Usage : use this configuration when your number of runs is very
  //                  big and you are not interested in the per run statistics
  //                  and histograms.
  //
  //  Notice that in any case, the global statistics and histograms for all
  //runs is always present in memory and on the file. This global statistics
  //is an object of class TResults, pointed to by the pointer gGs.
  //
  const Int_t kBufferSize = 64;
  Int_t i,bin;
  Int_t kfluo;
  Axis_t afluo;
  T3Vector x0,K,E;
  Bool_t gGpok;
  gGs->RefreshDet();
  if (run<=0) {
    gMes->SetName("Gen");
    gMes->SetTitle("TSpontan");
    gMes->M(Error_M,1,"run number must be >= 1. We change it !");
    run = TMath::Abs(run);
    if (run==0) run += 1;
  }
  fRun = run;
  cout << "Run : " << fRun << endl;
  *gMes->fListing << "Run : " << fRun << endl;
  //Insures that gOutside is defined
  if (!gOutside) {
    Bool_t b;
    gOutside = new TOpticMaterial("Outside","Material of the outside world",
      kFALSE,1.0,1.0e+6);
    gOutside->IsIsotropic(1.0);
    b = gOutside->CheckIt();
  }
  //Defines fFullName
  Int_t l,l1;
  TString NameOnly;
  NameOnly = fName;
  l1 = kBufferSize - 10;
  l = NameOnly.Length();
  if (l>l1) NameOnly.Remove(l1);
  fFullName  = NameOnly;
  fFullName.Append('_');
  fFullName += fRun;
  //initializes the summary statistics of class TPublication
  gGpok = (runstat && (!ForgetLast));
  if (!gGp && gGpok) gGp = new TPublication("Summary","Runs",gGpok);
  fRunStat = runstat;
  //Verifies that shapes are numbered
  Int_t nbofsh;
  if (!gLit->fShapeNumbered)
    nbofsh = gLit->GiveNbToShape();
  //Handle the pointer to the previous run. Even if gCs is put to 0 without
  //having been deleted, pointer to the previous run is not lost, it stays
  //inside gLit->fResults.
  if (gCs) {
    if (ForgetLast) {
      gLit->fResults.Remove(gCs);
      delete gCs;
      gCs = 0;
    }
    else gCs->DelHistos();
  }
  gCs = 0;
  //Makes gCs point towards this run.
  if (fRunStat) gCs = new TResults(fFullName,fTitle,fRun,xparam);
  //Open the .root file for writing, if not yet done
  if (gLit->fFilesClosed) {
    gLit->OpenFilesW(runstat);
    gROOT->cd();
    if ((!runstat) && (gCs)) {
      delete gCs;
      gCs = 0;
    }
  }
  // We have to force a call to gLit->NewWavelength(), in case where the
  //radiation damage changes from run to run
  if (fWvlgth>0.0) gLit->NewWavelength(fWvlgth,kTRUE);
  //loop on generation of photons
  for (i=1;i<=nphot;i++) {
    gGs->fNpGener += 1;
    if (gCs) gCs->fNpGener += 1;
    //first determines wavelength and time of emission of photon and store results
    //in histograms
    if (!fWvlgthFixed) fMat->WaveAndLife(fWvlgth,fT0,kfluo);
    //update all values depending upon wavelength
    gLit->NewWavelength(fWvlgth);
    bin = gGs->fHTimeAll->Fill(fT0);
    bin = gGs->fHWvlgthAll->Fill(fWvlgth);
    if (gCs) {
      bin = gCs->fHTimeAll->Fill(fT0);
      bin = gCs->fHWvlgthAll->Fill(fWvlgth);
    }
    if (!fWvlgthFixed) {
      if (gGs->HasFluo()) {
        afluo = kfluo;
        bin = gGs->fHTimeEach->Fill(fT0,afluo);
        bin = gGs->fHWvlgthEach->Fill(fWvlgth,afluo);
      }  //if (gGs->HasFluo())
      if ((gCs) && (gCs->HasFluo())) {
        afluo = kfluo;
        bin = gCs->fHTimeEach->Fill(fT0,afluo);
        bin = gCs->fHWvlgthEach->Fill(fWvlgth,afluo);
      }  //if (gCs)
    }  //if (!fWvlgthFixed)
    //generates the photon
    fBeam->Generate(x0,K,E);
    Short_t ks = fChooseIndex;
    fPhot = new TPhoton(fRun,i,x0,fSupplShape,fWvlgth,fT0,K,E,ks);
    //follow the photon from its birth to its death
    fPhot->Move(fGenFace);
    if (gGs->fNpAbnorm>TLitPhys::Get()->Anomalies()) {
      gMes->SetName("Gen");
      gMes->SetTitle("TSpontan");
      gMes->M(kill_prog,2,"too many anomalies");
    }
    //record death point, if asked for
    if (fFillDeath) FillDeath();
    delete fPhot;
    fPhot = 0;
  }//end for (Int_t i=0;i<nphot;i++)
  //Put statistics of this run into the tree.
  if (gCs) {
    gCs->Conclusion();
    gLit->fLitFile->cd();
    gLit->fLitNb += gLit->fLitTree->Fill();
    gROOT->cd();
  }
}
void TSpontan::InitP() {
  //Pointers to 0
  fHX0        = 0;
  fHY0        = 0;
  fHZ0        = 0;
  fBeam       = 0;
  fPhot       = 0;
  fSupplShape = 0;
  fMat        = 0;
  fFillDeath  = kFALSE;
  fWvlgth     = -1.0;
}
void TSpontan::Print() const {
  //Prints everything about spontaneous source
  //
  cout << endl;
  cout << "Spontaneous source : " << fName.Data() << endl;
  cout << "Title              : " << fTitle.Data() << endl;
  cout << endl;
  //listing
  *gMes->fListing << endl;
  *gMes->fListing << "Spontaneous source : " << fName.Data() << endl;
  *gMes->fListing << "Title              : " << fTitle.Data() << endl;
  *gMes->fListing << endl;
}
void TSpontan::SetFillDeath(TH1F *h1,TH1F *h2,TH1F *h3) {
  //  To be called once in order that the coordinates of the photons seen
  //be recorded into the provided histograms : 
  // - h1 for the x World Coordinate
  // - h2 for the y World Coordinate
  // - h3 for the z World Coordinate
  //  The creation and deletion of the histograms h1/2/3 has to be handled
  //by the user inside his CINT code. h1/2/3 must have been booked before
  //calling SetFillDeath
  //
  fFillDeath = kTRUE;
  fHX0 = h1;
  fHY0 = h2;
  fHZ0 = h3;
}
void TSpontan::SetWvlgth(Double_t wvlgth) {
  //  Changes the generated wavelength in case of wavelength not generated by
  //the material of the shape.
  if (fWvlgthFixed) fWvlgth = wvlgth;
}
